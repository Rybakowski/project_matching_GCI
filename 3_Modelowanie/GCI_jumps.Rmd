---
title: "GCI_jumps"
author: "Radosław Rybakowski"
date: "2023-12-17"
output: "html"
---

# GDP growth caused by GCI indicators jumps with PanelMatch package

### Libraries

```{r Funkcje, echo=FALSE}
source("matching_functions.R")

```

```{r Biblioteki, echo = FALSE, include = FALSE}
library(tidyverse)
library(writexl)
library(panelView)
library(PanelMatch)
library(furrr)
library(kableExtra)

data <- readxl::read_xlsx(r"(C:\Users\rados\OneDrive - SGH\Nowy_projekt_BNK\2_Przetwarzanie_danych\Data_merging\database_2023_12_22.xlsx)")

dict_GCI <- readxl::read_xlsx(r"(C:\Users\rados\OneDrive - SGH\Nowy_projekt_BNK\dict_master.xlsx)",
										sheet = "GCI") %>% 
	mutate(variables = paste0("wf_", variables))

dict_cou <- readxl::read_xlsx(r"(C:\Users\rados\OneDrive - SGH\Nowy_projekt_BNK\dict_master.xlsx)")
```

## Function to detect a jump

Assume, that jump exist if:

-   In period equal "jump_years" we have jump larger or equal "min_jump",

-   In period "check_years" - number of years after potential jump, level of variable doesn't drop, so jump is sustained

```{r Function to detect jumps}

vector <- c(1,1,3,3,3,3,3,1,3)

temp <- detect_jump(vector,
				jump_years = 1,
				check_years = 1,
				min_jump = 0.025)

temp
```

```{r Calculating jumps}

data_wf <- data %>% 
	select(cou, year, starts_with("wf")) 

data_group <- data_wf %>%
	select(-wf_TBPC) %>% #zmienna przyjmuje wartość zero
	group_by(cou) %>%
	arrange(cou, year)

data_dynamics <- data_group %>% 
	mutate(across(
		.cols = starts_with("wf"),
		.fns = ~.x/dplyr::lag(.x)
	)) %>% 
	filter(year != 2008) %>% 
	mutate(across(
		.cols = starts_with("wf"),
		.fns = ~ purrr::accumulate(.x, \(acc, nxt) acc*nxt)
	)) 
```

```{r, choosing jumps}
jumps_args <- list(
				is.dynamic = TRUE,
				jump_years = 1,
				check_years = 3,
				min_jump = 0.03)

data_jumps <- jump_data_proces(jumps_args)

```

### Jumps summary - which variables have large number of countries?

```{r jumps_summary}
jumps_sum_df <- jumps_summary()

jumps_sum_df 
```

## Jumps visualization

```{r countries_treated}
filter_jumps <- treated_columns(wf_EOSQ067)
dict_cou %>% 
	filter(cou %in% filter_jumps) %>% 
	select(cou, country)

```

```{r countries jumps line plot}
visual_jumps(wf_EOSQ067)
```

```{r Panel visualization}
visual_panel(wf_EOSQ067)
```

## Modelling

Choose appropiate variable to model

```{r prepare data to model}
data_model <- data_to_model(wf_EOSQ067)


```

Perform matching

```{r Panel Match,message=FALSE, warning=FALSE, include=FALSE}

results <- my_matching(outcome = "y_ham",
							  iterations = 1000)

```

```{r covariate balance}
results 
```

```{r}
vars_to_test <- jumps_sum_df %>% 
	filter(value > 10) %>%
	select(name) %>%  
	unlist()
# vars_to_test
names(vars_to_test) <- vars_to_test
```

```{r Test many vars, include=FALSE}

test_variables <- function(var){
	data_model <- data_to_model({{var}}) # to trzeba poprawić
	results <- my_matching(iterations = 100,
								  df = data_model)
	results_df <- tibble(results = results) %>%
		mutate(results = map(results, .f = ~as.data.frame(.x))) %>% 
		mutate(names = names(results)) %>%
		unnest(cols = c(results)) %>% 
		select(names, everything())
	results_df
}
plan(multisession, workers = 4)
results_list <- furrr::future_map(vars_to_test,test_variables,
											 .options = furrr_options(seed = 123))
print("finish")
```

```{r Test summary}

all_df <- tibble(results = results_list) %>%
	mutate(variable = names(results)) %>%
	unnest(cols = c(results)) 
all_df_summary <- all_df %>%
	mutate(check = ifelse(`5%`> -0.005, 1, 0)) %>% 
	group_by(variable) %>% 
	summarize(sig_positive = mean(check)) %>% 
	left_join(dict_GCI, by = c("variable" = "variables")) %>% 
	arrange(desc(sig_positive))

# list_to_save <- list(all_df, all_df_summary)
# writexl::write_xlsx(list_to_save, "jumps_33_004_d_yham.xlsx")
all_df_summary


```

```{r,include=FALSE}
jumps_args_list <- list(
	is.dynamic = TRUE,
	jump_years = 1:3,
	check_years = 2:5,
	min_jump = 
		seq(from = 0.01,
			by = 0.01,
				length.out = 10)) %>% 
	cross()

one_var_df_proc <- function(list_jumps_args = jumps_args_list){
	list_names <- list_jumps_args %>% 
		map(.f = ~glue::glue_collapse(as.numeric(.x),"_")) 
	
	list_jumps_test <- list_jumps_args %>% 
		set_names(list_names) %>% 
		map(.f  = jump_data_proces_one,
			  column = wf_EOSQ067)
	
	output_df <- reduce(list_jumps_test, 
			left_join,
			by = c("cou","year")) %>% 
		ungroup()
	
	cor_test <- cor(output_df  %>% 
	 	select(-cou,-year)) 
	cor_test[cor_test != 1] <- NA
	cor_test[upper.tri(cor_test, diag = TRUE)] <- NA
	
	to_remove <- cor_test %>% 
		as.data.frame() %>% 
		rownames_to_column() %>% 
		pivot_longer(-rowname) %>% 
		drop_na() %>% 
		select(rowname) %>% 
		unique() %>% 
		unlist() %>% 
		unname()
	
	output_df <- output_df %>% 
		select(!all_of(to_remove))
	return(output_df)
}

data_onevar <- one_var_df_proc()
vars_to_test <- colnames(data_onevar) %>% 
	setdiff(c('cou', 'year'))
names(vars_to_test) <- vars_to_test

test_one_variable <- function(var){
	data_model <- data_to_model_one(
			{{var}},
			data_onevar
		)
	results <- my_matching(iterations = 100,
								  df = data_model)
	results_df <- tibble(results = results) %>%
		mutate(results = map(results, .f = ~as.data.frame(.x))) %>% 
		mutate(names = names(results)) %>%
		unnest(cols = c(results)) %>% 
		select(names, everything())
	return(results_df)
}

plan(multisession, workers = 4)
results_list <- furrr::future_map(vars_to_test, test_one_variable,
											 .options = furrr_options(seed = 123))

```

```{r}
all_df <- tibble(results = results_list) %>%
	mutate(variable = names(results)) %>%
	unnest(cols = c(results)) 
all_df_summary <- all_df %>%
	mutate(check = ifelse(`5%`> -0.005, 1, 0)) %>% 
	group_by(variable) %>% 
	summarize(sig_positive = mean(check)) %>% 
	arrange(desc(sig_positive))

# list_to_save <- list(all_df, all_df_summary)
# writexl::write_xlsx(list_to_save, "jumps_33_004_d_yham.xlsx")
all_df_summary

```
